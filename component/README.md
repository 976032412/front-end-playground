从简单的模块化到组件化
=======================


用代码来总结从简单模块化到组件化的一个过程，*全部代码详见目录`./code/`*

###1. 最初的阶段：简单的分模块，页面级别

*代码参见 `./code/v1.0/`*

在这个阶段，是典型的MVC模式，而View层基本就是按照页面来切分模块，例如`v1.0.js`中就分为 `首页 indexPage`，`新闻页 newsPage`，`详情页 detailPage` 3个模块。

####存在较为明显的问题:

**1. 界面层的逻辑主要集中在模板中**

查看`render`函数，基本没有什么操作，主要交给模板进行处理，这样的导致模板有着太多的业务逻辑.
```
render: function (data) {
    var $el = _.template(pageTpl, data);
    $('#container').append($el);
}
```

**2. 代码冗余**

例子中的页面较少，难以提现。但是我们可以想象一下，随着项目越变越大，页面越来越多，每一个页面都会有一些相同的动作，例如`初始化init`,`渲染render`,`更新update`,`销毁destroy`等等

容易犯的错误就是简单的**copy and paste**, 这个错误在接触到的前端项目中见过太多次了。

**3. 代码维护难 **

仅仅看`v1.0`的代码，暂时是比较一致的，但是这种一致是通过约定来达到的，而约定在团队开发中往往是无法保证代码质量的, 因为开发人员质量参差不齐，编码习惯不同等原因导致很难达到同一个水平（函数名命名，各种最佳实践）。所以如果可以有一个框架来进行约束，尽可能的去统一大家的水准，这对于提高代码质量是非常有好处的，而且具有相同标准的模块可以降低代码的学习成本，因为每一个模块都是类似的，只要读懂了一个模块之后，后面的学习曲线就变得平坦了。举个例子：现在有项目采用`Backbone`来进行模块化开发，所有的模块都遵循backbone的标准，有过backbone经验的开发人员新加入项目组，他就可以很快进入项目。这个对于没有标准的模块来讲，这个是很难实现的。



###2. 阶段2: 利用框架标准，使用继承体系，并合理抽象模块

*代码参见 `./code/v1.1/`*

在这个版本中，通过引入了继承体系，通过创建一个基类来确定共有的接口`render`, `init`, `uiEvents`等，子类继承基类来扩展。这样子解决了两个问题

- 代码冗余
- 代码维护难

解决了这两个问题之后就剩下抽象粒度过粗的问题。细粒度的对象有助于组件的复用，进而提高系统的可维护性和开发速度。当然，细粒度应该是合理的，不能够过细。过细会导致过于负责的继承体系。对一个系统（应用）的设计和抽象是一个非常重要的过程，一个设计良好的系统可伸缩性强，维护一个设计糟糕的系统则是苦不堪言。这一点相信大家都有体会。

现在进入实例，目前，整个对象系统只有`页面 Page` 这一个对象，而如果继续深入分析，还可以抽象出另外几个对象
- 新闻简要 `NewsBrief`
- 新闻详情 `NewsDetail`
- 广告 `Advertisement`
- 列表 `List`
- 弹出窗口 `Window`
- 导航栏 `Navigation`
- 下拉菜单 `DropMenu`

其中部分是领域对象（系统特有的组件，如：`NewsBrief`, `Advertisement`），部分是通用对象（UI组件,如`Window`,`DropMenu`）

####在阶段2的改造过程中遇到的问题
**1. 又开始出现冗余代码**
冗余代码主要是组件的创建和管理，例如在代码中出现大量这样子的代码：
```
var nav = this.nav || new Navigation().render();
if (!this.nav) {
    this.$el.append(nav);
    this.nav = nav;
} else {
    nav.show();
}
```
有大量的重复代表相同的模式，而相同的模式一般可以进行抽象；上面的例子代码究竟是在做些什么？简单描述为以下步骤：

1. 创建组件
2. 缓存组件（用的时候不用重新创建）

进一步来想，组件和Dom一样，其实也是一个树形结构。那么管理组件的方式和管理Dom的方式其实是类似的。通过 `appendChild()`, `removeChild()`, `getChildById()`等接口来实现对组件的管理，而组件的生命周期（创建，销毁，渲染等）则交给框架来处理。这样应该可以减少大量的代码。

而定义一个新的组件类型，很可能就能够变成描述树结构了，例如：

```
var Index = Com.extend({
    
    components: [{
        type: 'header'
    }, {
        type: 'list'
    }, {
        type: 'footer'
    }]
});

var index = new Index();

/*
 * 调用render函数，则index会通知它的子组件进行渲染（render）,子组件则会通知其子组件进行渲染
 */
index.render();

```
好，在阶段3进行这部分工作;


###3. 阶段3: 建立组件树
